<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js" ></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery-ui-1.10.1.custom.min.js"></script>
<body>
<canvas id='myCanvas' width='1000' height='750' style="border:1px solid #d3d3d3;">
	Canvas not supported
</canvas>
<br/>
<table>
	First transformation: 
	<tr>
	<select id="UTT1_switch" class="UTT1">
	  <option value="+" selected="selected">+</option>
	  <option value="-">-</option>
	</select>
		
	<select id="UTT1_Major" class="UTT1">
	  <option value="1">1</option>
	  <option value="2" selected="selected">2</option>
	  <option value="3">3</option>
	  <option value="4">4</option>
	  <option value="5">5</option>
	  <option value="6">6</option>
	  <option value="7">7</option>
	  <option value="8">8</option>
	  <option value="9">9</option>
	  <option value="10">10</option>
	  <option value="11">11</option>
	</select>

	<select id="UTT1_Minor" class="UTT1">
	  <option value="1">1</option>
	  <option value="2" selected="selected">2</option>
	  <option value="3">3</option>
	  <option value="4">4</option>
	  <option value="5">5</option>
	  <option value="6">6</option>
	  <option value="7">7</option>
	  <option value="8">8</option>
	  <option value="9">9</option>
	  <option value="10">10</option>
	  <option value="11">11</option>
	</select>
	<div id="UTT1Disp"/>
	</tr>
	<br/>
	Second transformation: <tr>
	<select id="UTT2_switch" class="UTT2">
	  <option value="+">+</option>
	  <option value="-" selected="selected">-</option>
	</select>
		
	<select id="UTT2_Major" class="UTT2">
	  <option value="1">1</option>
	  <option value="2">2</option>
	  <option value="3">3</option>
	  <option value="4" selected="selected">4</option>
	  <option value="5">5</option>
	  <option value="6">6</option>
	  <option value="7">7</option>
	  <option value="8">8</option>
	  <option value="9">9</option>
	  <option value="10">10</option>
	  <option value="11">11</option>
	</select>

	<select id="UTT2_Minor" class="UTT2">
	  <option value="1">1</option>
	  <option value="2">2</option>
	  <option value="3">3</option>
	  <option value="4">4</option>
	  <option value="5" selected="selected">5</option>
	  <option value="6">6</option>
	  <option value="7">7</option>
	  <option value="8">8</option>
	  <option value="9">9</option>
	  <option value="10">10</option>
	  <option value="11">11</option>
	</select>
	<div id="UTT2Disp"/>
	</tr>
	<input type="button" onclick="buildGraph()" value="Get Chord Graph">
</table>
</body>
<script type="text/javascript">
	$(document).ready(function(){
		$(".UTT1 , .UTT2").bind('change',function(){
			$("#" + this.className + "Disp").text("< " + $("#" + this.className + "_switch").val() + ", " + $("#" + this.className + "_Major").val() + ", " + $("#" + this.className + "_Minor").val() + " >");
		});
		$(".UTT1 , .UTT2").trigger('change');
	});
	var curGraph = -1;
	var circleRadius = 40;
	var circleXUnit = 100;
	var circleYUnit = 100;

	var defaultLineWidth = 2;
	var defaultLineColor = "black";
	var defaultTextColor = "black";

	var defaultArrowWidth = 4;
	var defaultArrowColor = "black";
	var defaultFillColor = "white";
	var chordPathWidth = 5;
	var chordPathColor	= "dark blue";

	var selectedLineWidth = 4;
	var selectedLineColor = "blue";
	var selectedFillColor = "light blue";

	var highlightedLineWidth = 4;
	var highlightedLineColor = "blue";
	var highlightedFillColor = "light blue";

	var firstTime = true;
	var gridMargin = 100; 
	//Gotta keep track of which chords/circles are currently selected, by graph index
	//Each selected chord entry is a tuple with [xIndex, yIndex, chordName]
	//Currently the max is 2, but in the future we may want more of them
	selected = [];
	//Gotta keep track of which chords/circles are currently highlighted, by graph index
	//Each highlighted chord has the same tuple format as above.
	//These are used to highlight other chords in the graph that are of identical name to the selected chords
	//It is also used when the user locks down a path, and wants to create another
	highlightedChords = [];
	var highlightedX1 = -1;
	var highlightedY1 = -1;
	var highlightedChordName1 = "";
	var highlightedX2 = -1;
	var highlightedY2 = -1;
	var highlightedChordName2 = "";
	
	//add dashedLine to the context:
	/*eff the dashed line for the moment
	var CP = window.CanvasRenderingContext2D && CanvasRenderingContext2D.prototype;
	if (CP.lineTo) {
	    CP.dashedLine = function(x, y, x2, y2, dashArray) {
	        if (!dashArray) dashArray=[10,5];
		    if (dashLength==0) dashLength = 0.001; // Hack for Safari
		    var dashCount = dashArray.length;
		    this.moveTo(x, y);
		    var dx = (x2-x), dy = (y2-y);
		    var slope = dx ? dy/dx : 1e15;
		    var distRemaining = Math.sqrt( dx*dx + dy*dy );
		    var dashIndex=0, draw=true;
		    while (distRemaining>=0.1){
		      var dashLength = dashArray[dashIndex++%dashCount];
		      if (dashLength > distRemaining) dashLength = distRemaining;
		      var xStep = Math.sqrt( dashLength*dashLength / (1 + slope*slope) );
		      if (dx<0) xStep = -xStep;
		      x += xStep
		      y += slope*xStep;
		      this[draw ? 'lineTo' : 'moveTo'](x,y);
		      distRemaining -= dashLength;
		      draw = !draw;
		    }
	    }
	}*/

	function toType(obj) {
		return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()
	}

	function drawCircle(xCenter, yCenter, radius, lineWidth, lineColor, fillColor){
		console.log("drawing circle with color/width: (" + lineColor + "," + lineWidth + ")");
		var c=document.getElementById("myCanvas");
		var canvasCtx=c.getContext("2d");
		canvasCtx.beginPath();
		canvasCtx.arc(xCenter, yCenter, radius, 0,2*Math.PI);
		canvasCtx.closePath();

		//fill
		canvasCtx.fillStyle = getHexFromColorName(fillColor);
		canvasCtx.fill()
		//stroke
		canvasCtx.lineWidth = lineWidth;
		canvasCtx.strokeStyle = getHexFromColorName(lineColor);
		canvasCtx.stroke();
	}
	function writeChordText(canvasCtx, xLoc, yLoc, chordText, textColor){
		canvasCtx.font = "bold 12px sans-serif";
		canvasCtx.fillStyle = textColor;
		canvasCtx.fillText(chordText, xLoc, yLoc);
	}
	function drawArrowHead(xLocStart, yLocStart, sizeX, sizeY, direction){
		var c=document.getElementById("myCanvas");
		var canvasCtx=c.getContext("2d");
		canvasCtx.beginPath();
		canvasCtx.moveTo(xLocStart, yLocStart);

	}
	function drawArrowLine(xLocStart, yLocStart, xLocEnd, yLocEnd, lineWidth, lineColor){
		var c=document.getElementById("myCanvas");
		var canvasCtx=c.getContext("2d");
		canvasCtx.beginPath();
		canvasCtx.moveTo(xLocStart, yLocStart);
		canvasCtx.lineTo(xLocEnd, yLocEnd);
		canvasCtx.lineWidth = lineWidth;
		canvasCtx.strokeStyle = getHexFromColorName(lineColor);
      	canvasCtx.stroke();
	}
	function drawArrowDashedLine(xLocStart, yLocStart, xLocEnd, yLocEnd, lineWidth, lineColor){
		var c=document.getElementById("myCanvas");
		var canvasCtx=c.getContext("2d");
		canvasCtx.dashedLine(xLocStart, yLocStart, xLocEnd, yLocEnd, [10,10]);
		//canvasCtx.lineWidth = lineWidth;
		//canvasCtx.strokeStyle = getHexFromColorName(lineColor);
      	canvasCtx.stroke();
	}
	function drawArrowBetweenNodes(nodeStartX, nodeStartY, nodeEndX, nodeEndY, lineWidth, lineColor){
		var circleRadiusX = circleRadius;
		var circleRadiusY = circleRadius;
		var nodesWrap = false;
		var lineDirection = -1;//direction will be a number from 0-3 depiction direction 0 = up, 1 = right, 2 = down, 3 = left
		if (nodeStartX == nodeEndX){
			circleRadiusX = 0;
			if (Math.abs(nodeStartY - nodeEndY) > 1){
				nodesWrap = true;
				if (nodeStartY > nodeEndY){
					lineDirection = 2;//if the start node is above, the direction of the line is down
				}
				else{
					lineDirection = 0;
				}
			}

			if (nodeStartY > nodeEndY){
				circleRadiusY = circleRadiusY * -1;
			}
		}
		else if (nodeStartY == nodeEndY){
			circleRadiusY = 0;
			if (Math.abs(nodeStartX - nodeEndX) > 1){
				nodesWrap = true;
				if (nodeStartX > nodeEndX){
					lineDirection = 1;//if the start node is to the right, the direction of the line is right
				}
				else{
					lineDirection = 3;
				}
			}
			if (nodeStartX > nodeEndX){
				circleRadiusX = circleRadiusX * -1;
			}
		}

		var lineStartX = circleXUnit * nodeStartX + circleRadiusX + gridMargin;
		var lineStartY = circleYUnit * nodeStartY + circleRadiusY + gridMargin;
		var lineEndX = circleXUnit * nodeEndX - circleRadiusX + gridMargin;
		var lineEndY = circleYUnit * nodeEndY - circleRadiusY + gridMargin;

		
		if (nodesWrap == false){
			drawArrowLine(lineStartX, lineStartY, lineEndX, lineEndY, lineWidth, lineColor);
			console.log("drawing arrow from indices: (" + nodeStartX + "," + nodeStartY + ")" + "(" + nodeEndX + "," + nodeEndY + "), and lineLocs: (" + lineStartX + "," + lineStartY + "),(" + lineEndX + "," + lineEndY + ")");
		}
		else{
			//draw dotted line toward the edge of the graph to indicate 
			//that the node graph wraps around
			var dottedLineLength = circleRadius;
			lineStartX = circleXUnit * nodeStartX + gridMargin;
			lineStartY = circleYUnit * nodeStartY + gridMargin;
			var lineEndX = lineStartX;
			var lineEndY = lineStartY;
			switch (lineDirection){
			case 0: 
				lineStartY = lineStartY - dottedLineLength;
				lineEndY = lineStartY - dottedLineLength;
				break;
			case 1:
				lineStartX = lineStartX + dottedLineLength;
				lineEndX = lineStartX + dottedLineLength;
				break;
			case 2: 
				lineStartY = lineStartY + dottedLineLength;
				lineEndY = lineStartY + dottedLineLength;
				break;
			case 3:
				lineStartX = lineStartX - dottedLineLength;
				lineEndX = lineStartX - dottedLineLength;
				break;
			}
			drawArrowLine(lineStartX, lineStartY, lineEndX, lineEndY, lineWidth, lineColor);
		}
	}
	function clearCanvas(){
		var c=document.getElementById("myCanvas");
		var ctx=c.getContext("2d");
		ctx.clearRect(0,0, c.width, c.height);
	}
	function clearCircle(xCenter, yCenter, radius){
		var c=document.getElementById("myCanvas");
		var ctx=c.getContext("2d");
		ctx.beginPath();
		ctx.arc(xCenter, yCenter, radius, 0,2*Math.PI);
		ctx.save();
		ctx.clip();//from: http://stackoverflow.com/questions/10396991/clearing-circular-regions-from-html5-canvas   BALLER!
		ctx.clearRect(0,0, c.width, c.height);
		ctx.restore();
	}
	function buildChordNode(xIndex, yIndex, chordString, lineWidth, lineColor, fillColor, textColor){
		//console.log("building chord node with params: (" + xIndex + "," + yIndex + "," + chordString + ","+ lineWidth + ",'" + lineColor + "','" + fillColor + "','" + textColor + "')");
		//console.log("of types: (" + toType(xIndex) + "," + toType(yIndex) + "," + toType(chordString) + ","+ toType(lineWidth) + ",'" + toType(lineColor) + "','" + toType(fillColor) + "','" + toType(textColor) + "')");
		//console.log("circleXUnit is " + circleXUnit);
		//console.log("circleYUnit is " + circleYUnit);
		var c=document.getElementById("myCanvas");
		var ctx=c.getContext("2d");

		var circleCenterXLoc = circleXUnit * xIndex + gridMargin;
		var circleCenterYLoc = circleYUnit * yIndex + gridMargin;
		//draw the outline and fill if needed
		var strokeDiff = Math.ceil((selectedLineWidth - defaultLineWidth) / 2) + 2;
		drawCircle(circleCenterXLoc, circleCenterYLoc, circleRadius - strokeDiff, lineWidth, lineColor, fillColor);
		//write the chord name
		var estimatedTextSize = 44;
		writeChordText(ctx, circleCenterXLoc - (estimatedTextSize * .5), circleCenterYLoc, chordString, textColor);
		//draw arrows to neighbors
	}
	function getNodeByIndex(xIndex, yIndex){
	    chordNodes =curGraph.getElementsByTagName("ChordNode");
		for (var k = 0; k < chordNodes.length; k++)
		{
			var curNodeIndexX = parseInt(chordNodes[k].getAttribute("xIndex"));
			var curNodeIndexY = parseInt(chordNodes[k].getAttribute("yIndex"));
			if (curNodeIndexX == xIndex && curNodeIndexY == yIndex){
				return chords[k];
			}
		}
	}
	function getNodeNameByIndex(xIndex, yIndex){
		node = getNodeByIndex(xIndex, yIndex);
		return node.getAttribute("chordName");
	}
	function getNodePitchesByIndex(xIndex, yIndex){
		node = getNodeByIndex(xIndex, yIndex);
		pitchesNode = node.getElementsByTagName("Pitches")
		pitchNodes = pitchesNode[0].childNodes;
		pitches = [];
		var whitespace = /^\s*$/;
		for (var l = 0; l < pitchNodes.length; l++){
			if (!whitespace.test(pitchNodes[l].textContent)){
				pitches.push(pitchNodes[l].textContent);
			}
		}
		console.log(pitches);
		return pitches;
	}
	//x and y pairs are the indices for the nodes in the graph
	function getChordPath(x1, y1, x2, y2){
		var url = "";
		url += $("#UTT1_switch").val() + "/";
		url += $("#UTT1_Major").val() + "/";
		url += $("#UTT1_Minor").val() + "/";
		url += $("#UTT2_switch").val() + "/";
		url += $("#UTT2_Major").val() + "/";
		url += $("#UTT2_Minor").val() + "/";
		/*pitches1 = getNodePitchesByIndex(x1, y1);
		pitches2 = getNodePitchesByIndex(x2, y2);
		for (var m = 0; m < pitches1.length; m++){
			url += pitches1[m] +"/";
		}
		for (var m = 0; m < pitches1.length; m++){
			url += pitches2[m] +"/";
		}*/
		url += x1 + "/";
		url += y1 + "/";
		url += x2 + "/";
		url += y2 + "/";
		$.get( url, function( data ) {
			parser=new DOMParser();
  			pathXml=parser.parseFromString(data,"text/xml");
  			chordsInPath=pathXml.getElementsByTagName("ChordNode");
  			var curChord = chordsInPath[0], prevChord = 0;
  			for (var crd = 0; crd < chordsInPath.length; crd++){
  				prevChord = curChord;
  				if (crd == 0) continue;
  				curChord = chordsInPath[crd];
  				curChordX = parseInt(curChord.getAttribute("xIndex"));
  				curChordY = parseInt(curChord.getAttribute("yIndex"));
  				curChordName = curChord.getAttribute("chordName");
  				prevChordX = parseInt(prevChord.getAttribute("xIndex"));
  				prevChordY = parseInt(prevChord.getAttribute("yIndex"));
  				prevChordName = prevChord.getAttribute("chordName");
  				console.log("drawing arrow from chord [" + prevChordX + ", " + prevChordY + ", " + prevChordName + "] to [" + curChordX + ", " + curChordY + ", " + curChordName + "]" );
  				drawArrowBetweenNodes(prevChordX, prevChordY, curChordX, curChordY, chordPathWidth, chordPathColor);
  			}
		});
	}
	function inCircle(center_x, center_y, radius, x, y){
    	dist = Math.sqrt(Math.pow((center_x - x), 2) + Math.pow((center_y - y), 2));
    	return (dist <= radius);
	}
	/*function isHighlighted(curX, curY){
		var retVal = -1;
		for (var h = 0; h < selected.length; h++){
			var highlightedX = highlighted[h][0];
			var highlightedY = highlighted[h][1];
			var highlightedName = highlighted[h][2];
			if (highlightedX == curX && highlightedY == curY){
				retVal = h;
			}
			console.log("highlighted" + h + " is (" + highlightedX + "," + highlightedY + ")");
		}
		console.log("isHighlighted(" + curX + "," + curY + ") = " + retVal);
		return retVal;
	}*/
	function isSelected(curX, curY){
		var retVal = -1;
		console.log("length of selected: " + selected.length);
		for (var h = 0; h < selected.length; h++){
			var selectedX = selected[h][0];
			var selectedY = selected[h][1];
			var selectedName = selected[h][2];
			if (selectedX == curX && selectedY == curY){
				retVal = h;
			}
			console.log("selected[" + h + "] is (" + selectedX + "," + selectedY + ")");
		}
		console.log("isSelected(" + curX + "," + curY + ") = " + retVal);
		return retVal;
	}
	function removeSelectedChord(index){
		//this means we're de-selecting a circle, and it needs to be redrawn
		selectedX = selected[index][0];
		selectedY = selected[index][1];
		selectedChordName = selected[index][2];

		var circleCenterXLoc = circleXUnit * selectedX + gridMargin;
		var circleCenterYLoc = circleYUnit * selectedY + gridMargin;
		//clear first
		clearCircle(circleCenterXLoc, circleCenterYLoc, circleRadius);
		//rebuild
		buildChordNode(selectedX, selectedY, selectedChordName, defaultLineWidth, defaultLineColor, defaultFillColor, defaultTextColor);
		//remove
		selected.splice(index, 1);
	}
	function addSelectedChord(curNodeX, curNodeY, lineWidth, lineColor, fillColor){
		var curNodeName = getNodeNameByIndex(curNodeX, curNodeY);
		var tuple = [];
		tuple.push(curNodeX, curNodeY, curNodeName);
		
		var circleCenterXLoc = circleXUnit * curNodeX + gridMargin;
		var circleCenterYLoc = circleYUnit * curNodeY + gridMargin;

		clearCircle(circleCenterXLoc, circleCenterYLoc, circleRadius);

		buildChordNode(curNodeX, curNodeY, curNodeName, selectedLineWidth, selectedLineColor, selectedFillColor, defaultTextColor);
		
		//drawCircle(circleCenterXLoc, circleCenterYLoc, circleRadius - strokeDiff, selectedLineWidth, fillColor);
		selected.push(tuple);

		//now get the path from the previously selected chord to this newly added chord, 
		//if there are any other selected chords
		if (selected.length > 1){
			console.log("getting best path");
			//get the previously selected chord's indices
			previousTuple = selected[selected.length - 2];
			previousNodeX = previousTuple[0];
			previousNodeY = previousTuple[1];
			/*shortestPath = */getChordPath(previousNodeX, previousNodeY, curNodeX, curNodeY);
			//drawChordPath(shortestPath);
		}
	}
	function getHexFromColorName(colorName){
		var colorHex = "";
		switch(colorName){
			case "dark blue":
				colorHex = "#0c03aa";
				break;
			case "blue":
				colorHex = "#007fff";
				break;
			case "light blue":
				colorHex = "#cceaff";
				break;
			case "red":
				colorHex = "#ff333e";
				break;
			case "light red":
				colorHex = "#ffcccf";
				break;
			case "green":
				colorHex = "#39c045";
				break;
			case "light green":
				colorHex = "#bdea9f";
				break;
			case "white":
				colorHex = "#ffffff";
				break;
			case "black":
				colorHex = "#000000";
				break;
		}
		console.log("returning '" + colorHex + "' for '" + colorName + "'");
		return colorHex;
	}
	function findCanvasClickLoc(event){
		var c=document.getElementById("myCanvas");
		canvasLeft = c.offsetLeft;
		canvasTop = c.offsetTop;
	    var x = event.pageX - canvasLeft,
	        y = event.pageY - canvasTop;
	    // Collision detection between clicked offset and element.
	    chords=xmlDoc.getElementsByTagName("ChordNode");
			//console.log("chords.length is: " + chords.length);
		for (var i = 0; i < chords.length; i++)
		{
			var curNodeX = parseInt(chords[i].getAttribute("xIndex"));
			var curNodeY = parseInt(chords[i].getAttribute("yIndex"));
			var circleCenterXLoc = circleXUnit * curNodeX + gridMargin;
			var circleCenterYLoc = circleYUnit * curNodeY + gridMargin;
	        if (inCircle(circleCenterXLoc, circleCenterYLoc, circleRadius, x, y)){
				var ctx=c.getContext("2d");
				console.log("in circle for graph index: (" + curNodeX + "," + curNodeY + ")");
				selectedNumber = isSelected(curNodeX, curNodeY);
				if (selectedNumber != -1){
					console.log("found selected circle " + selectedNumber);
					removeSelectedChord(selectedNumber)
				}
				else{
					console.log("circle not highlighted yet");
					addSelectedChord(curNodeX, curNodeY, selectedLineWidth, "blue", "blue");	
				}
	        }
		}	
	}
	function addCanvasListener(){
		var c=document.getElementById("myCanvas");
		// Add event listener for `click` events.
		c.addEventListener('click', findCanvasClickLoc, false);
	}
	function removeCanvasListener(){
		var c=document.getElementById("myCanvas");
		// Add event listener for `click` events.
		c.removeEventListener('click', findCanvasClickLoc, false);
	}
	function buildGraph(){
		var url = "";
		url += $("#UTT1_switch").val() + "/";
		url += $("#UTT1_Major").val() + "/";
		url += $("#UTT1_Minor").val() + "/";
		url += $("#UTT2_switch").val() + "/";
		url += $("#UTT2_Major").val() + "/";
		url += $("#UTT2_Minor").val() + "/";
		clearCanvas();
		selected = [];
		highlighted = [];
		$.get( url, function( data ) {
			if (window.DOMParser){
				parser=new DOMParser();
	  			xmlDoc=parser.parseFromString(data,"text/xml");
	  			curGraph = xmlDoc;
	  			//alert(xmlDoc.getElementsByTagName("chordNode"));//[0].childNodes[0].nodeValue;
	  			chords=xmlDoc.getElementsByTagName("ChordNode");
	  			console.log("chords.length is: " + chords.length);
				for (i = 0; i < chords.length; i++)
				{
					//console.log("current chord name: " + chords[i].getAttribute("chordName"));
					//console.log("current chord xIndex: " + chords[i].getAttribute("xIndex"));
					//console.log("current chord xIndex: " + chords[i].getAttribute("yIndex"));
					var curNodeX = parseInt(chords[i].getAttribute("xIndex"));
					var curNodeY = parseInt(chords[i].getAttribute("yIndex"));
					buildChordNode(curNodeX, curNodeY, chords[i].getAttribute("chordName"), defaultLineWidth, defaultLineColor, defaultFillColor, defaultTextColor);
					chordNodeChildren = chords[i].childNodes;
					console.log("chordNodeChildren.length = " + chordNodeChildren.length);
					for (j = 0; j < chordNodeChildren.length; j++){
						if (chordNodeChildren[j].tagName == "Neighbors"){
							console.log("found the neighbors");
							neighborNodes = chordNodeChildren[j].childNodes;
							console.log("neighborNodes.length = " + neighborNodes.length);
							for (k = 0; k < neighborNodes.length; k++){
								//gotta check for the neighbor tag because there are some blank text tags in between
								if (neighborNodes[k].tagName == "Neighbor"){
									drawArrowBetweenNodes(curNodeX, curNodeY, parseInt(neighborNodes[k].getAttribute("xIndex")), parseInt(neighborNodes[k].getAttribute("yIndex")), defaultArrowWidth, defaultArrowColor);
									//console.log("found neighbor at: (" + neighborNodes[k].getAttribute("xIndex") + "," + neighborNodes[k].getAttribute("yIndex") + ")");
								}
							}
						}
						
					}
				}
	  		}
	  		else{//Internet Explorer
	  			alert("Please upgrade to the 21st century and get a different browser");
	  		}
			//buildChordNode({{colNode.xInd}}, {{colNode.yInd}}, "{{colNode.chordName}}");
			//{% for n in colNode.neighbors %}
			//drawArrowBetweenNodes({{colNode.xInd}}, {{colNode.yInd}}, {{n.0.0}}, {{n.0.1}});
			//{% endfor %}
		});
		if (firstTime){
			//instead of using firstTime, we could just do it on document load, as long as the canvas is not visible on docload
			addCanvasListener();
			firstTime = false;
		}
	}

</script>
</html>
