<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js" ></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery-ui-1.10.1.custom.min.js"></script>
<body>
<canvas id='myCanvas' width='1000' height='750' >
	Canvas not supported
</canvas>
<br/>
<table>
	First transformation: 
	<tr>
	<select id="UTT1_mode" class="UTT1">
	  <option value="+" selected="selected">+</option>
	  <option value="-">-</option>
	</select>
		
	<select id="UTT1_maj" class="UTT1">
	  <option value="1">0</option>
	  <option value="1">1</option>
	  <option value="2" selected="selected">2</option>
	  <option value="3">3</option>
	  <option value="4">4</option>
	  <option value="5">5</option>
	  <option value="6">6</option>
	  <option value="7">7</option>
	  <option value="8">8</option>
	  <option value="9">9</option>
	  <option value="10">10</option>
	  <option value="11">11</option>
	</select>

	<select id="UTT1_min" class="UTT1">
	  <option value="1">0</option>
	  <option value="1">1</option>
	  <option value="2" selected="selected">2</option>
	  <option value="3">3</option>
	  <option value="4">4</option>
	  <option value="5">5</option>
	  <option value="6">6</option>
	  <option value="7">7</option>
	  <option value="8">8</option>
	  <option value="9">9</option>
	  <option value="10">10</option>
	  <option value="11">11</option>
	</select>

	Transformation ID: <input type="text" id="UTT1_Name" size="1" maxLength="1" value="X"/>
	<div id="UTT1Disp"/>
	</tr>
	<br/>
	Second transformation: <tr>
	<select id="UTT2_mode" class="UTT2">
	  <option value="+">+</option>
	  <option value="-" selected="selected">-</option>
	</select>
		
	<select id="UTT2_maj" class="UTT2">
	  <option value="1">0</option>
	  <option value="1">1</option>
	  <option value="2">2</option>
	  <option value="3">3</option>
	  <option value="4" selected="selected">4</option>
	  <option value="5">5</option>
	  <option value="6">6</option>
	  <option value="7">7</option>
	  <option value="8">8</option>
	  <option value="9">9</option>
	  <option value="10">10</option>
	  <option value="11">11</option>
	</select>

	<select id="UTT2_min" class="UTT2">
	  <option value="1">0</option>	
	  <option value="1">1</option>
	  <option value="2">2</option>
	  <option value="3">3</option>
	  <option value="4">4</option>
	  <option value="5" selected="selected">5</option>
	  <option value="6">6</option>
	  <option value="7">7</option>
	  <option value="8">8</option>
	  <option value="9">9</option>
	  <option value="10">10</option>
	  <option value="11">11</option>
	</select>
	Transformation ID: <input type="text" id="UTT2_Name" size="1" maxLength="1" value="Y"/>
	<div id="UTT2Disp"/>
	</tr>
	<input type="button" onclick="buildGraph()" value="Get Chord Graph"><br/>
	<input id="addShortcutButton" type="button" onClick="addShortcut()"/><div id="lastTransformation"/> <br/>
	<div id="validDisp"/>
</table>
</body>
<script type="text/javascript">
	$(document).ready(function(){
		$(".UTT1 , .UTT2").bind('change',function(){
			$("#" + this.className + "Disp").text("< " + $("#" + this.className + "_mode").val() + ", " + $("#" + this.className + "_maj").val() + ", " + $("#" + this.className + "_min").val() + " >");
		});
		$(".UTT1 , .UTT2").trigger('change');
		//$("#addShortcutButton").bind('click', addShortCut());
	});
	var curGraph = -1;
	var circleRadius = 40;
	var circleXUnit = 100;
	var circleYUnit = 100;

	var defaultLineWidth = 2;
	var defaultLineColor = "black";
	var defaultTextColor = "black";

	var defaultArrowWidth = 4;
	var defaultArrowColor = "black";
	var defaultFillColor = "white";
	var chordPathWidth = 5;
	var chordPathColor	= "green";

	var selectedLineWidth = 4;
	var selectedLineColor = "blue";
	var selectedFillColor = "light blue";
	var selectedTextColor = "black";

	var highlightedLineWidth = 4;
	var highlightedLineColor = "red";
	var highlightedFillColor = "light red";
	var highlightedTextColor = "black";

	var defaultBackgroundColor = "white";

	var invalidText = "The graph produced does not contain all 24 major and minor triads";
	var firstTime = true;
	var gridMargin = 100; 
	//Gotta keep track of which chords/circles are currently selected, by graph index
	//Each selected chord entry is a tuple with [xIndex, yIndex, chordName]
	//Currently the max is 2, but in the future we may want more of them
	selected = [];
	//Gotta keep track of which chords/circles are currently highlighted, by graph index
	//Each highlighted chord has the same tuple format as above.
	//These are used to highlight other chords in the graph that are of identical name to the selected chords
	//It is also used when the user locks down a path, and wants to create another
	highlighted = [];
	//Gotta keep track of the paths that are highlighted as well
	//Each path entry is a tuple [pathDistance, pathTransformationString, [chordList]] 
	//where chordList is a list of [x, y, name] tuples, denoting each chord it visits
	paths = [];

	var highlightedX1 = -1;
	var highlightedY1 = -1;
	var highlightedChordName1 = "";
	var highlightedX2 = -1;
	var highlightedY2 = -1;
	var highlightedChordName2 = "";
	
	//add dashedLine to the context:
	/*eff the dashed line for the moment
	var CP = window.CanvasRenderingContext2D && CanvasRenderingContext2D.prototype;
	if (CP.lineTo) {
	    CP.dashedLine = function(x, y, x2, y2, dashArray) {
	        if (!dashArray) dashArray=[10,5];
		    if (dashLength==0) dashLength = 0.001; // Hack for Safari
		    var dashCount = dashArray.length;
		    this.moveTo(x, y);
		    var dx = (x2-x), dy = (y2-y);
		    var slope = dx ? dy/dx : 1e15;
		    var distRemaining = Math.sqrt( dx*dx + dy*dy );
		    var dashIndex=0, draw=true;
		    while (distRemaining>=0.1){
		      var dashLength = dashArray[dashIndex++%dashCount];
		      if (dashLength > distRemaining) dashLength = distRemaining;
		      var xStep = Math.sqrt( dashLength*dashLength / (1 + slope*slope) );
		      if (dx<0) xStep = -xStep;
		      x += xStep
		      y += slope*xStep;
		      this[draw ? 'lineTo' : 'moveTo'](x,y);
		      distRemaining -= dashLength;
		      draw = !draw;
		    }
	    }
	}*/

	function toType(obj) {
		return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()
	}

	function drawCircle(xCenter, yCenter, radius, lineWidth, lineColor, fillColor){
		//console.log("drawing circle with color/width: (" + lineColor + "," + lineWidth + ")");
		var c=document.getElementById("myCanvas");
		var canvasCtx=c.getContext("2d");
		canvasCtx.beginPath();
		canvasCtx.arc(xCenter, yCenter, radius, 0,2*Math.PI);
		canvasCtx.closePath();

		//fill
		canvasCtx.fillStyle = getRGBaFromColorName(fillColor);
		canvasCtx.fill()
		//stroke
		canvasCtx.lineWidth = lineWidth;
		canvasCtx.strokeStyle = getRGBaFromColorName(lineColor);
		canvasCtx.stroke();
	}
	function writeChordText(canvasCtx, xLoc, yLoc, chordText, textColor){
		canvasCtx.font = "bold 12px sans-serif";
		canvasCtx.fillStyle = textColor;
		canvasCtx.fillText(chordText, xLoc, yLoc);
	}
	function drawArrowHead(xLocStart, yLocStart, sizeX, sizeY, direction){
		var c=document.getElementById("myCanvas");
		var canvasCtx=c.getContext("2d");
		canvasCtx.beginPath();
		canvasCtx.moveTo(xLocStart, yLocStart);

	}
	function drawArrowLine(xLocStart, yLocStart, xLocEnd, yLocEnd, lineWidth, lineColor, alpha){
		var c=document.getElementById("myCanvas");
		var canvasCtx=c.getContext("2d");
		canvasCtx.beginPath();
		canvasCtx.moveTo(xLocStart, yLocStart);
		canvasCtx.lineTo(xLocEnd, yLocEnd);
		canvasCtx.lineWidth = lineWidth;
		alpha = typeof alpha !== 'undefined' ? alpha : 1;
		canvasCtx.strokeStyle = getRGBaFromColorName(lineColor, alpha);
      	canvasCtx.stroke();
	}
	function drawArrowDashedLine(xLocStart, yLocStart, xLocEnd, yLocEnd, lineWidth, lineColor){
		var c=document.getElementById("myCanvas");
		var canvasCtx=c.getContext("2d");
		canvasCtx.dashedLine(xLocStart, yLocStart, xLocEnd, yLocEnd, [10,10]);
		//canvasCtx.lineWidth = lineWidth;
		//canvasCtx.strokeStyle = getRGBaFromColorName(lineColor);
      	canvasCtx.stroke();
	}
	//when the nodes are not neighbors, you gotta make a translucent arc arrow to show that it's a shortcut
	function drawShortCutArrow(nodeStartX, nodeStartY, nodeEndX, nodeEndY, lineWidth, lineColor){
		//short cut arrows will come off the sides of the circle
		//first, get the x and y distances for the corners of the circle
		var cornerDist = Math.sqrt((circleRadius * circleRadius) / 2);
		//these flags are describing the first node in terms of the 2nd (first node) isRight (of the second node)
		var isLeft = false;
		var isAbove = false;
		if (nodeStartX <= nodeEndX){
			isLeft = true;
		}
		if (nodeStartY <= nodeEndY){
			isAbove = true;
		}

		if (isLeft){
			xDist = cornerDist;
		}
		else{
			xDist = cornerDist * -1;
		}

		if (isAbove){
			yDist = cornerDist;
		}
		else{
			yDist = cornerDist * -1;
		}

		//console.log("isLeft is: " + String(isLeft));
		//console.log("isAbove is: " + String(isAbove));
		var lineStartX = Math.floor(circleXUnit * nodeStartX + gridMargin + xDist);
		var lineStartY = Math.floor(circleXUnit * nodeStartY + gridMargin + yDist);
		var lineEndX = Math.floor(circleXUnit * nodeEndX + gridMargin + (xDist * -1));
		var lineEndY = Math.floor(circleXUnit * nodeEndY + gridMargin + (yDist * -1));
		console.log("drawing shortcut from indices: (" + nodeStartX + "," + nodeStartY + ")" + "(" + nodeEndX + "," + nodeEndY + "), and lineLocs: (" + lineStartX + "," + lineStartY + "),(" + lineEndX + "," + lineEndY + ")");
		drawArrowLine(lineStartX, lineStartY, lineEndX, lineEndY, lineWidth, lineColor, .2);
	}
	function drawArrowBetweenNodes(nodeStartX, nodeStartY, nodeEndX, nodeEndY, lineWidth, lineColor){
		var circleRadiusX = circleRadius;
		var circleRadiusY = circleRadius;
		var nodesWrap = false;
		var lineDirection = -1;//direction will be a number from 0-3 depiction direction 0 = up, 1 = right, 2 = down, 3 = left
		if (nodeStartX == nodeEndX){
			circleRadiusX = 0;
			if (Math.abs(nodeStartY - nodeEndY) > 1){
				nodesWrap = true;
				if (nodeStartY > nodeEndY){
					lineDirection = 2;//if the start node is above, the direction of the line is down
				}
				else{
					lineDirection = 0;
				}
			}

			if (nodeStartY > nodeEndY){
				circleRadiusY = circleRadiusY * -1;
			}
		}
		else if (nodeStartY == nodeEndY){
			circleRadiusY = 0;
			if (Math.abs(nodeStartX - nodeEndX) > 1){
				nodesWrap = true;
				if (nodeStartX > nodeEndX){
					lineDirection = 1;//if the start node is to the right, the direction of the line is right
				}
				else{
					lineDirection = 3;
				}
			}
			if (nodeStartX > nodeEndX){
				circleRadiusX = circleRadiusX * -1;
			}
		}

		var lineStartX = circleXUnit * nodeStartX + circleRadiusX + gridMargin;
		var lineStartY = circleYUnit * nodeStartY + circleRadiusY + gridMargin;
		var lineEndX = circleXUnit * nodeEndX - circleRadiusX + gridMargin;
		var lineEndY = circleYUnit * nodeEndY - circleRadiusY + gridMargin;

		
		if (nodesWrap == false){
			drawArrowLine(lineStartX, lineStartY, lineEndX, lineEndY, lineWidth, lineColor);
			console.log("drawing arrow from indices: (" + nodeStartX + "," + nodeStartY + ")" + "(" + nodeEndX + "," + nodeEndY + "), and lineLocs: (" + lineStartX + "," + lineStartY + "),(" + lineEndX + "," + lineEndY + ")");
		}
		else{
			//draw dotted line toward the edge of the graph to indicate 
			//that the node graph wraps around
			var dottedLineLength = circleRadius;
			lineStartX = circleXUnit * nodeStartX + gridMargin;
			lineStartY = circleYUnit * nodeStartY + gridMargin;
			var lineEndX = lineStartX;
			var lineEndY = lineStartY;
			switch (lineDirection){
			case 0: 
				lineStartY = lineStartY - dottedLineLength;
				lineEndY = lineStartY - dottedLineLength;
				break;
			case 1:
				lineStartX = lineStartX + dottedLineLength;
				lineEndX = lineStartX + dottedLineLength;
				break;
			case 2: 
				lineStartY = lineStartY + dottedLineLength;
				lineEndY = lineStartY + dottedLineLength;
				break;
			case 3:
				lineStartX = lineStartX - dottedLineLength;
				lineEndX = lineStartX - dottedLineLength;
				break;
			}
			drawArrowLine(lineStartX, lineStartY, lineEndX, lineEndY, lineWidth, lineColor);
		}
	}
	//this function tells if nodes are right next two eachother, except that they wrap around the edge of the graph
	function nodesAreAdjacentWithWrap(curNodeX, curNodeY, neighborX, neighborY, xMax, yMax){
		var retVal = false;
		if (neighborX == curNodeX){
			if (curNodeY == yMax && neighborY == 0 || curNodeY == 0 && neighborY == yMax){
				//this is not a shortcut, it's a wrap-around
				retVal = true;
			}
		}
		if (neighborY == curNodeY){
			if (curNodeX == xMax && neighborX == 0 || curNodeX == 0 && neighborX == xMax){
				//this is not a shortcut, it's a wrap-around
				retVal = true;
			}
		}
		return retVal;
	}
	function drawShortCutsOnly(){
		chords=curGraph.getElementsByTagName("ChordNode");
		for (i = 0; i < chords.length; i++)
		{
			var curNodeX = parseInt(chords[i].getAttribute("xIndex"));
			var curNodeY = parseInt(chords[i].getAttribute("yIndex"));
			chordNodeChildren = chords[i].childNodes;

	  		var parentChordsTag = curGraph.getElementsByTagName("Chords");
	  		xMax = parentChordsTag[0].getAttribute("xMax");
	  		yMax = parentChordsTag[0].getAttribute("yMax");
			console.log("finding shortcuts for ("  + curNodeX +  "," + curNodeY + ")");
			for (j = 0; j < chordNodeChildren.length; j++){
				if (chordNodeChildren[j].tagName != "Neighbors") continue;
				//console.log("found the neighbors");
				neighborNodes = chordNodeChildren[j].childNodes;
				console.log("neighborNodes.length = " + neighborNodes.length);
				for (k = 0; k < neighborNodes.length; k++){
					//gotta check for the neighbor tag because there are some blank text tags in between
					if (neighborNodes[k].tagName != "Neighbor") continue;
					neighborX = parseInt(neighborNodes[k].getAttribute("xIndex"));
					neighborY = parseInt(neighborNodes[k].getAttribute("yIndex"));
					distanceString = neighborNodes[k].getAttribute("distance");
					//identify adjacent wrapping nodes- those are not shortcuts:
					console.log("found neighbor at (" + neighborX +  "," + neighborY +  "," + distanceString + ")");
					if (nodesAreAdjacentWithWrap(curNodeX, curNodeY, neighborX, neighborY, xMax, yMax)) continue;

					if ((Math.abs(neighborX - curNodeX) + Math.abs(neighborY - curNodeY)) > 1){
						console.log("found shortcut at (" + neighborX +  "," + neighborY + ")");
						drawShortCutArrow(curNodeX, curNodeY, neighborX, neighborY, defaultArrowWidth, defaultArrowColor);
					}
					//console.log("found neighbor at: (" + neighborNodes[k].getAttribute("xIndex") + "," + neighborNodes[k].getAttribute("yIndex") + ")");
				}				
			}
		}
	}
	function clearCanvas(){
		var c=document.getElementById("myCanvas");
		var ctx=c.getContext("2d");
		ctx.clearRect(0,0, c.width, c.height);
	}
	function clearCircle(xCenter, yCenter, radius){
		var c=document.getElementById("myCanvas");
		var ctx=c.getContext("2d");
		ctx.beginPath();
		ctx.arc(xCenter, yCenter, radius, 0,2*Math.PI);
		ctx.save();
		ctx.clip();//from: http://stackoverflow.com/questions/10396991/clearing-circular-regions-from-html5-canvas   BALLER!
		ctx.clearRect(0,0, c.width, c.height);
		ctx.restore();
	}
	function buildChordNode(xIndex, yIndex, chordString, lineWidth, lineColor, fillColor, textColor){
		//console.log("building chord node with params: (" + xIndex + "," + yIndex + "," + chordString + ","+ lineWidth + ",'" + lineColor + "','" + fillColor + "','" + textColor + "')");
		//console.log("of types: (" + toType(xIndex) + "," + toType(yIndex) + "," + toType(chordString) + ","+ toType(lineWidth) + ",'" + toType(lineColor) + "','" + toType(fillColor) + "','" + toType(textColor) + "')");
		//console.log("circleXUnit is " + circleXUnit);
		//console.log("circleYUnit is " + circleYUnit);
		var c=document.getElementById("myCanvas");
		var ctx=c.getContext("2d");

		var circleCenterXLoc = circleXUnit * xIndex + gridMargin;
		var circleCenterYLoc = circleYUnit * yIndex + gridMargin;
		//draw the outline and fill if needed
		var strokeDiff = Math.ceil((selectedLineWidth - defaultLineWidth) / 2) + 2;
		drawCircle(circleCenterXLoc, circleCenterYLoc, circleRadius - strokeDiff, lineWidth, lineColor, fillColor);
		//write the chord name
		var estimatedTextSize = 44;
		writeChordText(ctx, circleCenterXLoc - (estimatedTextSize * .5), circleCenterYLoc, chordString, textColor);
		//draw arrows to neighbors
	}
	function getNodeByIndex(xIndex, yIndex){
	    chordNodes =curGraph.getElementsByTagName("ChordNode");
		for (var k = 0; k < chordNodes.length; k++)
		{
			var curNodeIndexX = parseInt(chordNodes[k].getAttribute("xIndex"));
			var curNodeIndexY = parseInt(chordNodes[k].getAttribute("yIndex"));
			if (curNodeIndexX == xIndex && curNodeIndexY == yIndex){
				return chords[k];
			}
		}
	}
	function getNodeNameByIndex(xIndex, yIndex){
		node = getNodeByIndex(xIndex, yIndex);
		return node.getAttribute("chordName");
	}
	function getNodePitchesByIndex(xIndex, yIndex){
		node = getNodeByIndex(xIndex, yIndex);
		pitchesNode = node.getElementsByTagName("Pitches")
		pitchNodes = pitchesNode[0].childNodes;
		pitches = [];
		var whitespace = /^\s*$/;
		for (var l = 0; l < pitchNodes.length; l++){
			if (!whitespace.test(pitchNodes[l].textContent)){
				pitches.push(pitchNodes[l].textContent);
			}
		}
		console.log(pitches);
		return pitches;
	}
	//x and y pairs are the indices for the nodes in the graph
	function getChordPath(x1, y1, x2, y2){
		var url = "";
		//get the UTT from the stored xml, not from the form
		//since they're interacting with the already-made graph
	  	var parentChordsTag = xmlDoc.getElementsByTagName("Chords");
		url += parentChordsTag[0].getAttribute("UTT1_mode") + "/";
		url += parentChordsTag[0].getAttribute("UTT1_maj") + "/";
		url += parentChordsTag[0].getAttribute("UTT1_min") + "/";
		url += parentChordsTag[0].getAttribute("UTT1_name") + "/";
		url += parentChordsTag[0].getAttribute("UTT2_mode") + "/";
		url += parentChordsTag[0].getAttribute("UTT2_maj") + "/";
		url += parentChordsTag[0].getAttribute("UTT2_min") + "/";
		url += parentChordsTag[0].getAttribute("UTT2_name") + "/";
		url += new String(x1) + "/";
		url += new String(y1) + "/";
		url += new String(x2) + "/";
		url += new String(y2) + "/";
		$.get( url, function( data ) {
			parser=new DOMParser();
  			pathXml=parser.parseFromString(data,"text/xml");
  			chordsInPath=pathXml.getElementsByTagName("ChordNode");
  			//set the first chord, since we have to iterate in pairs
  			var curChord;
  			curPath = [];
  			for (var crd = 0; crd < chordsInPath.length; crd++){
  				curChord = chordsInPath[crd];
  				curChordX = parseInt(curChord.getAttribute("xIndex"));
  				curChordY = parseInt(curChord.getAttribute("yIndex"));
  				curChordName = curChord.getAttribute("chordName");
  				curPath.push([curChordX, curChordY, curChordName]);
  			}
  			parentTag = pathXml.getElementsByTagName("Path");
  			pathDist = parseFloat(parentTag[0].getAttribute("distance"));
  			pathTrans = parentTag[0].getAttribute("transformations");
  			addPathToStack([pathDist, pathTrans, curPath]);
		});
	}
	function inCircle(center_x, center_y, radius, x, y){
    	dist = Math.sqrt(Math.pow((center_x - x), 2) + Math.pow((center_y - y), 2));
    	return (dist <= radius);
	}
	function isSelected(curX, curY){
		var retVal = -1;
		console.log("length of selected: " + selected.length);
		for (var h = 0; h < selected.length; h++){
			var selectedX = selected[h][0];
			var selectedY = selected[h][1];
			if (selectedX == curX && selectedY == curY){
				retVal = h;
			}
			console.log("selected[" + h + "] is (" + selectedX + "," + selectedY + ")");
		}
		console.log("isSelected(" + curX + "," + curY + ") = " + retVal);
		return retVal;
	}
	//this function is a reverse iterator, for when we want the most recently selected node of a certain chord name
	function isSelectedByNameReverse(chordName){
		var retVal = -1;
		console.log("length of selected: " + selected.length);
		for (var h = selected.length - 1; h >= 0 ; h--){
			var selectedName = selected[h][2];
			if (selectedName == chordName){
				retVal = h;
			}
		}
		console.log("isSelected(" + chordName + ") = " + retVal);
		return retVal;
	}
	function checkForIdenticalNodes(nodeIndexX, nodeIndexY, nodeName, doAdd){
		chordNodes =curGraph.getElementsByTagName("ChordNode");
		for (var k = 0; k < chordNodes.length; k++)
		{
			var curNodeName = chordNodes[k].getAttribute("chordName");
			if (curNodeName == nodeName){
				var curNodeIndexX = parseInt(chordNodes[k].getAttribute("xIndex"));
				var curNodeIndexY = parseInt(chordNodes[k].getAttribute("yIndex"));
				if (curNodeIndexX != nodeIndexX && curNodeIndexY != nodeIndexY){
					//double check that it's not already selected
					if (isSelected(curNodeIndexX, curNodeIndexY) == -1){
						addChordToStack(curNodeIndexX, curNodeIndexY, true, false);
					}
				}
			}
		}
	}
	function removeIdenticalNodes(chordName){
		for (var s = 0; s < highlighted.length; s++){
			curName = highlighted[s][2];
			if (chordName == curName){
				removeChordFromStack(s, true, false);
			}
		}
	}
	function removeChordFromStack(index, isHighlighted, doAuxFunctions){
		var array;
		if (isHighlighted){
			array = highlighted;
		}
		else{
			array = selected;
		}
		//this means we're de-selecting a circle, and it needs to be redrawn
		arrayX = array[index][0];
		arrayY = array[index][1];
		arrayChordName = array[index][2];

		var circleCenterXLoc = circleXUnit * arrayX + gridMargin;
		var circleCenterYLoc = circleYUnit * arrayY + gridMargin;
		//clear first
		clearCircle(circleCenterXLoc, circleCenterYLoc, circleRadius);
		//rebuild
		buildChordNode(arrayX, arrayY, arrayChordName, defaultLineWidth, defaultLineColor, defaultFillColor, defaultTextColor);
		
		//remove
		var arrayName = "_selected_";
		if (isHighlighted) arrayName = "_highlighted_";
		console.log("removing node (" + arrayX + "," + arrayY + ") from array " + arrayName);
		array.splice(index, 1);
		if (doAuxFunctions){
			removeIdenticalNodes(arrayChordName);
			console.log("popping from the paths stack");
			removePathFromStack(paths.length - 1);
		}

	}
	function addChordToStack(curNodeX, curNodeY, isHighlighted, computePath){
		var array;
		var lineWidth;
		var lineColor;
		var fillColor;
		var textColor;
		if (isHighlighted){
			array = highlighted;
			lineWidth = highlightedLineWidth;
			lineColor = highlightedLineColor;
			fillColor = highlightedFillColor;
			textColor = highlightedTextColor;
		}
		else{
			array = selected;
			lineWidth = selectedLineWidth;
			lineColor = selectedLineColor;
			fillColor = selectedFillColor;
			textColor = selectedTextColor;
		}

		var curNodeName = getNodeNameByIndex(curNodeX, curNodeY);
		var tuple = [];
		tuple.push(curNodeX, curNodeY, curNodeName);
		
		var circleCenterXLoc = circleXUnit * curNodeX + gridMargin;
		var circleCenterYLoc = circleYUnit * curNodeY + gridMargin;

		clearCircle(circleCenterXLoc, circleCenterYLoc, circleRadius);

		buildChordNode(curNodeX, curNodeY, curNodeName, lineWidth, lineColor, fillColor, textColor);
		
		//drawCircle(circleCenterXLoc, circleCenterYLoc, circleRadius - strokeDiff, selectedLineWidth, fillColor);
		array.push(tuple);

		//now get the path from the previously selected chord to this newly added chord, 
		//if there are any other selected chords
		if (array.length > 1 && computePath){
			console.log("getting best path");
			//get the previously selected chord's indices
			previousTuple = array[array.length - 2];
			previousNodeX = previousTuple[0];
			previousNodeY = previousTuple[1];
			console.log("prevNode coordinates are: (" + previousNodeX + "," + previousNodeY + ")");
			/*shortestPath = */getChordPath(previousNodeX, previousNodeY, curNodeX, curNodeY);
			//drawChordPath(shortestPath);
		}
		if (computePath) checkForIdenticalNodes(curNodeX, curNodeY, curNodeName);
	}
	function printLastPath(){
		console.log("printing last path: " + paths[paths.length - 1][1]);
		if (paths.length > 0){
			$('#lastTransformation').text(paths[paths.length - 1][1]);
		}
		else{
			$('#lastTransformation').text("");
		}

	}
	//this function checks if the last node in the path is part of the _selected_ array
	//If not, it's part of _highlighted_, and you need to switch them
	//returns false if the destination tuple is only highlighted(and was not the one selected)
	function checkPathDestination(destTuple){
		//search the highlighted array first, by name AND index
		//if it's there, switch them. If not, you're good to go
		name = 2;//index of the name in a tuple
		for (var hl = 0; hl < highlighted.length; hl++){
			if (destTuple[0] == highlighted[hl][0] && destTuple[1] == highlighted[hl][1] && destTuple[name] == highlighted[hl][name]){
				//first, remove the highlighted chord we found (so we can later change it to selected)
				removeChordFromStack(hl, true);

				//change the selected chord that's the same as this chord to highlighted
				//the selected chord will be at (or close to) the end of the selected stack
				selectedIndex = isSelectedByNameReverse(destTuple[name]);
				if (selectedIndex != -1){
					var highlightX = selected[selectedIndex][0];
					var highlightY = selected[selectedIndex][1];
					removeChordFromStack(selectedIndex, false, false);
					console.log("highlighting (" + highlightX + "," + highlightY + ")");
					addChordToStack(highlightX, highlightY, true, false);
				}
				//now change the highlighted chord to selected 
				//you have to do this second, otherwise you'll just pull this chord 
				//when searching for the previously selected chord of same name
				//similarly you have to remove it from the highlighted stack before
				//adding the selected chord to the highlighted stack (see top, in scope)
				addChordToStack(destTuple[0], destTuple[1], false, false);
				break;
			}
		}

	}
	function addPathToStack(pathEntry){
		pathDistance = pathEntry[0];
		pathTrans = pathEntry[1];
		pathChordList = pathEntry[2];
		var curChord = pathChordList[0], prevChord = 0;
		//format of tuple is from the comments at top
		for (var crd = 0; crd < pathChordList.length; crd++){
			prevChord = curChord;
			if (crd == 0) continue;

			curChord = pathChordList[crd];
			curChordX = curChord[0];
			curChordY = curChord[1];
			curChordName = curChord[2];

			prevChordX = prevChord[0];
			prevChordY = prevChord[1];
			prevChordName = prevChord[2];

			console.log("drawing arrow from chord [" + prevChordX + ", " + prevChordY + ", " + prevChordName + "] to [" + curChordX + ", " + curChordY + ", " + curChordName + "]" );
			drawArrowBetweenNodes(prevChordX, prevChordY, curChordX, curChordY, chordPathWidth, chordPathColor);

			if (Math.abs(prevChordY - curChordY) > 1 || Math.abs(prevChordX - curChordX) > 1){
				//assumes no arrow heads
				//this means that the nodes wrap
				drawArrowBetweenNodes(curChordX, curChordY, prevChordX, prevChordY, chordPathWidth, chordPathColor);
			}

		}
		checkPathDestination(pathChordList[pathChordList.length - 1], pathChordList[0]);
		paths.push(pathEntry);
		printLastPath(pathTrans, pathDist);
	}
	function removePathFromStack(index){
		var curPath = paths[index][2];
		var curTuple = curPath[0];
		var clearLineWidth = 10;

		for (var t = 0; t < curPath.length; t++){
			prevTuple = curTuple;
			if (t == 0) continue;
			curTuple = curPath[t];
			curChordX = curTuple[0];
			curChordY = curTuple[1];
			curChordName = curTuple[2];

			prevChordX = prevTuple[0];
			prevChordY = prevTuple[1];
			prevChordName = prevTuple[2];
			//to clear a line, simply draw a line of the background color of sufficient width
			//we do both directions because this function automatically handles the wrapping case,
			//in which case the two directional arrows are in different locations
			drawArrowBetweenNodes(curChordX, curChordY, prevChordX, prevChordY, clearLineWidth, defaultBackgroundColor);
			drawArrowBetweenNodes(prevChordX, prevChordY, curChordX, curChordY, clearLineWidth, defaultBackgroundColor);

			//redraw regular arrows
			drawArrowBetweenNodes(curChordX, curChordY, prevChordX, prevChordY, defaultArrowWidth, defaultArrowColor);
			drawArrowBetweenNodes(prevChordX, prevChordY, curChordX, curChordY, defaultArrowWidth, defaultArrowColor);
		}

		paths.splice(index, 1);
	}
	function getLastTransformation(){
		text = document.getElementById('lastTransformation').textContent;
		console.log("getting lastTrans: " + text);
		if (text !== ""){
			return text;
		}
		else{
			return false;
		}
	}
	function addShortcut(){
		url = ""
		var parentChordsTag = xmlDoc.getElementsByTagName("Chords");
		url += parentChordsTag[0].getAttribute("UTT1_mode") + "/";
		url += parentChordsTag[0].getAttribute("UTT1_maj") + "/";
		url += parentChordsTag[0].getAttribute("UTT1_min") + "/";
		url += parentChordsTag[0].getAttribute("UTT1_name") + "/";
		url += parentChordsTag[0].getAttribute("UTT2_mode") + "/";
		url += parentChordsTag[0].getAttribute("UTT2_maj") + "/";
		url += parentChordsTag[0].getAttribute("UTT2_min") + "/";
		url += parentChordsTag[0].getAttribute("UTT2_name") + "/";
		lastTrans = getLastTransformation();
		console.log("trying to add shortcut, lastTrans is: " + lastTrans);

		if (lastTrans !== 'undefined') {
			console.log("lastTrans is true, adding it to url")
			url += lastTrans.replace(/\|/g, ".") + "/";
		}
		$.get( url, function( data ) {
			console.log("got the data back /addShortcut")
			parser=new DOMParser();
  			xmlDoc=parser.parseFromString(data,"text/xml");
			curGraph = xmlDoc;
			drawShortCutsOnly();
		});

	}
	function getRGBaFromColorName(colorName, alpha){
		alpha = typeof alpha !== 'undefined' ? alpha : 1;
		var colorRGBa = "rgba";
		switch(colorName){
			case "dark blue":
				colorRGBa += "(12, 3, 170, ";
				break;
			case "blue":
				colorRGBa += "(0, 127, 255, ";
				break;
			case "light blue":
				colorRGBa += "(204, 234, 255, ";
				break;
			case "red":
				colorRGBa += "(255, 51, 62, ";
				break;
			case "light red":
				colorRGBa += "(255, 204, 207, ";
				break;
			case "green":
				colorRGBa += "(57, 192, 69, ";
				break;
			case "light green":
				colorRGBa += "(189, 234, 159, ";
				break;
			case "white":
				colorRGBa += "(255, 255, 255, ";
				break;
			case "black":
				colorRGBa += "(0, 0, 0, ";
				break;
		}
		colorRGBa += String(alpha) + ")";
		//console.log("returning '" + colorRGBa + "' for '" + colorName + "'");
		return colorRGBa;
	}
	function findCanvasClickLoc(event){
		var c=document.getElementById("myCanvas");
		canvasLeft = c.offsetLeft;
		canvasTop = c.offsetTop;
	    var x = event.pageX - canvasLeft,
	        y = event.pageY - canvasTop;
	    // Collision detection between clicked offset and element.
	    chords=xmlDoc.getElementsByTagName("ChordNode");
			//console.log("chords.length is: " + chords.length);
		for (var i = 0; i < chords.length; i++)
		{
			var curNodeX = parseInt(chords[i].getAttribute("xIndex"));
			var curNodeY = parseInt(chords[i].getAttribute("yIndex"));
			var curChordName = chords[i].getAttribute("chordName");
			var circleCenterXLoc = circleXUnit * curNodeX + gridMargin;
			var circleCenterYLoc = circleYUnit * curNodeY + gridMargin;
	        if (inCircle(circleCenterXLoc, circleCenterYLoc, circleRadius, x, y)){
				var ctx=c.getContext("2d");
				console.log("in circle for graph index: (" + curNodeX + "," + curNodeY + ")");
				selectedNumber = isSelected(curNodeX, curNodeY);
				//you can only remove the last chord in the path
				if (selectedNumber != -1 && selectedNumber == selected.length - 1) {
					console.log("found selected circle " + selectedNumber);
					removeChordFromStack(selectedNumber, false, true);
				}
				//not a redundant conditional...
				else if (selectedNumber == -1){//&& (curchordName != lastSelectedChordName)
					//check that you're not selecting an identical chord to the last selected chord.
					selectedByName = isSelectedByNameReverse(curChordName);
					if (selectedByName == -1 || selectedByName != selected.length - 1){
						console.log("circle not selected, and not equivalent to last selected, adding");
						addChordToStack(curNodeX, curNodeY, false, true);	
					}
				}
	        }
		}	
	}
	function addCanvasListener(){
		var c=document.getElementById("myCanvas");
		// Add event listener for `click` events.
		c.addEventListener('click', findCanvasClickLoc, false);
	}
	function removeCanvasListener(){
		var c=document.getElementById("myCanvas");
		// Add event listener for `click` events.
		c.removeEventListener('click', findCanvasClickLoc, false);
	}
	function buildGraph(){
		var url = "";
		url += $("#UTT1_mode").val() + "/";
		url += $("#UTT1_maj").val() + "/";
		url += $("#UTT1_min").val() + "/";
		var trans1Name = $("#UTT1_Name").val();
		if (trans1Name == ""){
			trans1Name = "X";
		}
		url += trans1Name + "/";
		url += $("#UTT2_mode").val() + "/";
		url += $("#UTT2_maj").val() + "/";
		url += $("#UTT2_min").val() + "/";
		var trans2Name = $("#UTT2_Name").val();
		if (trans2Name == ""){
			trans2Name = "Y";
		}
		url += trans2Name + "/";
		clearCanvas();
		selected = [];
		highlighted = [];
		$.get( url, function( data ) {
			if (window.DOMParser){
				parser=new DOMParser();
	  			xmlDoc=parser.parseFromString(data,"text/xml");
	  			curGraph = xmlDoc;
	  			//alert(xmlDoc.getElementsByTagName("chordNode"));//[0].childNodes[0].nodeValue;
	  			var parentChordsTag = xmlDoc.getElementsByTagName("Chords");
	  			
	  			isValidGraph = ('true' === parentChordsTag[0].getAttribute("isValidGraph").toLowerCase());
	  			//console.log("isValidGraph is : " + String(isValidGraph));
	  			$('#validDisp').text("")
	  			if (isValidGraph == false){
	  				$('#validDisp').text(invalidText);
	  			}
	  			chords=xmlDoc.getElementsByTagName("ChordNode");
	  			console.log("chords.length is: " + chords.length);
				for (i = 0; i < chords.length; i++)
				{
					//console.log("current chord name: " + chords[i].getAttribute("chordName"));
					//console.log("current chord xIndex: " + chords[i].getAttribute("xIndex"));
					//console.log("current chord xIndex: " + chords[i].getAttribute("yIndex"));
					var curNodeX = parseInt(chords[i].getAttribute("xIndex"));
					var curNodeY = parseInt(chords[i].getAttribute("yIndex"));
					buildChordNode(curNodeX, curNodeY, chords[i].getAttribute("chordName"), defaultLineWidth, defaultLineColor, defaultFillColor, defaultTextColor);
					chordNodeChildren = chords[i].childNodes;
					//console.log("chordNodeChildren.length = " + chordNodeChildren.length);
					for (j = 0; j < chordNodeChildren.length; j++){
						if (chordNodeChildren[j].tagName == "Neighbors"){
							//console.log("found the neighbors");
							neighborNodes = chordNodeChildren[j].childNodes;
							console.log("neighborNodes.length = " + neighborNodes.length);
							for (k = 0; k < neighborNodes.length; k++){
								//gotta check for the neighbor tag because there are some blank text tags in between
								if (neighborNodes[k].tagName == "Neighbor"){
									drawArrowBetweenNodes(curNodeX, curNodeY, parseInt(neighborNodes[k].getAttribute("xIndex")), parseInt(neighborNodes[k].getAttribute("yIndex")), defaultArrowWidth, defaultArrowColor);
									//console.log("found neighbor at: (" + neighborNodes[k].getAttribute("xIndex") + "," + neighborNodes[k].getAttribute("yIndex") + ")");
								}
							}
						}
						
					}
				}
	  		}
	  		else{//Internet Explorer
	  			alert("Please upgrade to the 21st century and get a different browser");
	  		}
	  		drawArrowLine(5,7, 5, 0, 4, "black");
			//buildChordNode({{colNode.xInd}}, {{colNode.yInd}}, "{{colNode.chordName}}");
			//{% for n in colNode.neighbors %}
			//drawArrowBetweenNodes({{colNode.xInd}}, {{colNode.yInd}}, {{n.0.0}}, {{n.0.1}});
			//{% endfor %}
		});
		if (firstTime){
			//instead of using firstTime, we could just do it on document load, as long as the canvas is not visible on docload
			addCanvasListener();
			firstTime = false;
		}
	}

</script>
</html>
