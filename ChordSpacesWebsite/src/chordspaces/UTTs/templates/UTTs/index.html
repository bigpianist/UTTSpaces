<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js" ></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery-ui-1.10.1.custom.min.js"></script>
<body>
<canvas id='myCanvas' width='1000' height='750' style="border:1px solid #d3d3d3;">
	Canvas not supported
</canvas>
<br/>
<table>
	First transformation: 
	<tr>
	<select id="UTT1_switch" class="UTT1">
	  <option value="+" selected="selected">+</option>
	  <option value="-">-</option>
	</select>
		
	<select id="UTT1_Major" class="UTT1">
	  <option value="1">1</option>
	  <option value="2" selected="selected">2</option>
	  <option value="3">3</option>
	  <option value="4">4</option>
	  <option value="5">5</option>
	  <option value="6">6</option>
	  <option value="7">7</option>
	  <option value="8">8</option>
	  <option value="9">9</option>
	  <option value="10">10</option>
	  <option value="11">11</option>
	</select>

	<select id="UTT1_Minor" class="UTT1">
	  <option value="1">1</option>
	  <option value="2" selected="selected">2</option>
	  <option value="3">3</option>
	  <option value="4">4</option>
	  <option value="5">5</option>
	  <option value="6">6</option>
	  <option value="7">7</option>
	  <option value="8">8</option>
	  <option value="9">9</option>
	  <option value="10">10</option>
	  <option value="11">11</option>
	</select>
	<div id="UTT1Disp"/>
	</tr>
	<br/>
	Second transformation: <tr>
	<select id="UTT2_switch" class="UTT2">
	  <option value="+">+</option>
	  <option value="-" selected="selected">-</option>
	</select>
		
	<select id="UTT2_Major" class="UTT2">
	  <option value="1">1</option>
	  <option value="2">2</option>
	  <option value="3">3</option>
	  <option value="4" selected="selected">4</option>
	  <option value="5">5</option>
	  <option value="6">6</option>
	  <option value="7">7</option>
	  <option value="8">8</option>
	  <option value="9">9</option>
	  <option value="10">10</option>
	  <option value="11">11</option>
	</select>

	<select id="UTT2_Minor" class="UTT2">
	  <option value="1">1</option>
	  <option value="2">2</option>
	  <option value="3">3</option>
	  <option value="4">4</option>
	  <option value="5" selected="selected">5</option>
	  <option value="6">6</option>
	  <option value="7">7</option>
	  <option value="8">8</option>
	  <option value="9">9</option>
	  <option value="10">10</option>
	  <option value="11">11</option>
	</select>
	<div id="UTT2Disp"/>
	</tr>
	<input type="button" onclick="buildGraph()" value="Get Chord Graph">
</table>
</body>
<script type="text/javascript">
	$(document).ready(function(){
		$(".UTT1 , .UTT2").bind('change',function(){
			$("#" + this.className + "Disp").text("< " + $("#" + this.className + "_switch").val() + ", " + $("#" + this.className + "_Major").val() + ", " + $("#" + this.className + "_Minor").val() + " >");
		});
		$(".UTT1 , .UTT2").trigger('change');
	});
	var curGraph = -1;
	var circleRadius = 40;
	var circleXUnit = 100;
	var circleYUnit = 100;
	var darkBlueHex = "#007fff";
	var defaultCircleLineColor = "#000000"
	var defaultCircleLineWidth = 1;
	var selectedCircleLineWidth = 4;
	var firstTime = true;
	//Gotta keep track of which 2 circles are currently highlighted, by graph index
	//if only one circle is highlighted, it will always be stored in the "1" vars
	var highlightedX1 = -1;
	var highlightedY1 = -1;
	var highlightedX2 = -1;
	var highlightedY2 = -1;

	function drawCircle(canvasCtx, xCenter, yCenter, radius, width, color){
		//console.log("drawing circle with centerpoint: (" + xCenter + "," + yCenter + ")");
		canvasCtx.beginPath();
		canvasCtx.arc(xCenter, yCenter, radius, 0,2*Math.PI);
		canvasCtx.lineWidth = width;
		if (color == "blue"){
			canvasCtx.strokeStyle = darkBlueHex;
		}
		else{
			canvasCtx.strokeStyle = defaultCircleLineColor;
		}
		canvasCtx.stroke();
	}
	function writeChordText(canvasCtx, xLoc, yLoc, chordText){
		canvasCtx.font = "bold 12px sans-serif";
		canvasCtx.fillText(chordText, xLoc, yLoc);
	}
	function drawArrowHead(canvasCtx, xLocStart, yLocStart, size, direction){

	}
	function drawArrow(canvasCtx, xLocStart, yLocStart, xLocEnd, yLocEnd){
		canvasCtx.beginPath();
		canvasCtx.moveTo(xLocStart, yLocStart);
		canvasCtx.lineTo(xLocEnd, yLocEnd);
      	canvasCtx.stroke();
	}
	function drawArrowBetweenNodes(nodeStartX, nodeStartY, nodeEndX, nodeEndY){
		var c=document.getElementById("myCanvas");
		var ctx=c.getContext("2d");
		var circleRadiusX = circleRadius;
		var circleRadiusY = circleRadius;
		var nodesWrap = false;
		if (nodeStartX == nodeEndX){
			circleRadiusX = 0;
			if (Math.abs(nodeStartY - nodeEndY) > 1){
				nodesWrap = true;
			}

			if (nodeStartY > nodeEndY){
				circleRadiusY = circleRadiusY * -1;
			}
		}
		else if (nodeStartY == nodeEndY){
			circleRadiusY = 0;
			if (Math.abs(nodeStartX - nodeEndX) > 1){
				nodesWrap = true;
			}
			if (nodeStartX > nodeEndX){
				circleRadiusX = circleRadiusX * -1;
			}
		}

		var lineStartX = circleXUnit * (nodeStartX + .5) + circleRadiusX;
		var lineStartY = circleYUnit * (nodeStartY + .5) + circleRadiusY;
		var lineEndX = circleXUnit * (nodeEndX + .5) - circleRadiusX;
		var lineEndY = circleYUnit * (nodeEndY + .5) - circleRadiusY;

		
		if (nodesWrap == false){
			drawArrow(ctx, lineStartX, lineStartY, lineEndX, lineEndY);
			console.log("drawing arrow from indices: (" + nodeStartX + "," + nodeStartY + ")" + "(" + nodeEndX + "," + nodeEndY + "), and lineLocs: (" + lineStartX + "," + lineStartY + "),(" + lineEndX + "," + lineEndY + ")");
		}
		else{
			//draw dotted line toward the edge of the graph to indicate 
			//that the node graph wraps around
		}
	}
	function clearCanvas(){
		var c=document.getElementById("myCanvas");
		var ctx=c.getContext("2d");
		ctx.clearRect(0,0, c.width, c.height);
	}
	function clearCircle(xCenter, yCenter, radius){
		var c=document.getElementById("myCanvas");
		var ctx=c.getContext("2d");
		ctx.beginPath();
		ctx.arc(xCenter, yCenter, radius, 0,2*Math.PI);
		ctx.save();
		ctx.clip();//from: http://stackoverflow.com/questions/10396991/clearing-circular-regions-from-html5-canvas   BALLER!
		ctx.clearRect(0,0, c.width, c.height);
		ctx.restore();
	}
	function buildChordNode(xIndex, yIndex, chordString){
		console.log("building chord node with params: (" + xIndex + "," + yIndex + "," + chordString + ")");
		console.log("circleXUnit is " + circleXUnit);
		console.log("circleYUnit is " + circleYUnit);
		var c=document.getElementById("myCanvas");
		var ctx=c.getContext("2d");
		var circleCenterXLoc = circleXUnit * (xIndex + .5);
		var circleCenterYLoc = circleYUnit * (yIndex + .5);
		drawCircle(ctx, circleCenterXLoc, circleCenterYLoc, circleRadius, defaultCircleLineWidth, "");
		//write the chord name
		var estimatedTextSize = 44;
		writeChordText(ctx, circleCenterXLoc - (estimatedTextSize * .5), circleCenterYLoc, chordString);
		//draw arrows to neighbors
	}
	function getNodeByIndex(xIndex, yIndex){
	    chords=curGraph.getElementsByTagName("ChordNode");
			//console.log("chords.length is: " + chords.length);
		for (i = 0; i < chords.length; i++)
		{
			var curNodeX = parseInt(chords[i].getAttribute("xIndex"));
			var curNodeY = parseInt(chords[i].getAttribute("yIndex"));
			if (curNodeX == xIndex && curNodeY == yIndex){
				return chords[i];
			}
		}
	}
	function getNodeNameByIndex(xIndex, yIndex){
		node = getNodeByIndex(xIndex, yIndex);
		return node.getAttribute("chordName");
	}
	function inCircle(center_x, center_y, radius, x, y){
    	dist = Math.sqrt(Math.pow((center_x - x), 2) + Math.pow((center_y - y), 2));
    	return (dist <= radius);
	}
	function isHighlighted(curX, curY){
		var retVal = -1;
		if (highlightedX1 == curX && highlightedY1 == curY){
			retVal = 1;
		}
		else if (highlightedX2 == curX && highlightedY2 == curY){
			retVal = 2;
		}
		console.log("highlighted1 is (" + highlightedX1 + "," + highlightedY1 + ")")
		console.log("highlighted2 is (" + highlightedX2 + "," + highlightedY2 + ")")
		console.log("isHighlighted(" + curX + "," + curY + ") = " + retVal)
		return retVal;
	}
	function addCanvasListener(){
		var c=document.getElementById("myCanvas");
		// Add event listener for `click` events.
		c.addEventListener('click', function(event) {
		    canvasLeft = c.offsetLeft;
    		canvasTop = c.offsetTop;
		    var x = event.pageX - canvasLeft,
		        y = event.pageY - canvasTop;
		    // Collision detection between clicked offset and element.
		    chords=xmlDoc.getElementsByTagName("ChordNode");
  			//console.log("chords.length is: " + chords.length);
			for (i = 0; i < chords.length; i++)
			{
				var curNodeX = parseInt(chords[i].getAttribute("xIndex"));
				var curNodeY = parseInt(chords[i].getAttribute("yIndex"));
				var circleCenterXLoc = circleXUnit * (curNodeX + .5);
				var circleCenterYLoc = circleYUnit * (curNodeY + .5);
		        if (inCircle(circleCenterXLoc, circleCenterYLoc, circleRadius, x, y)){
					var ctx=c.getContext("2d");
					console.log("in circle");
					highlightedNumber = isHighlighted(curNodeX, curNodeY);
					if (highlightedNumber != -1){
						console.log("found highlighted circle " + highlightedNumber);
						//this means we're de-selecting a circle, and it needs to be redrawn
						clearCircle(circleCenterXLoc, circleCenterYLoc, circleRadius);
						var curNodeName = getNodeNameByIndex(curNodeX, curNodeY);
						buildChordNode(curNodeX, curNodeY, curNodeName);

						if (highlightedNumber == 1){
							//we need to move the 2nd highlighted circle up to the 1 position
							//since we trigger the search on having #2 highlighted (and thus 2 separate circles selected)
							highlightedX1 = highlightedX2;
							highlightedY1 = highlightedY2; 
						}
						//either highlightedNumber equals 2, or you've just moved highlighted X2/Y2 to highlighted X1/Y1, either way you need to reset highlighted X2/Y2
						highlightedX2 = -1;
						highlightedY2 = -1; 
					}
					else{
						console.log("circle not highlighted yet");
						//figure out if some other circle is already selected
						if (highlightedX1 != -1 && highlightedY1 != -1){
							console.log("one other circle is, though");
							if (highlightedX2 == -1 && highlightedY2 == -1){
								highlightedX2 = curNodeX;
								highlightedY2 = curNodeY;
								//clearCircle first if you want it to not just draw over whatever is there
								//Note: we want to embolden the line by making the stroke bigger
								////	This goes outside of the circle radius though
								////	So we have to subtract the difference in stroke from the radius
								var strokeDiff = (selectedCircleLineWidth - defaultCircleLineWidth) /2;
								drawCircle(ctx, circleCenterXLoc, circleCenterYLoc, circleRadius - strokeDiff, selectedCircleLineWidth, "blue");
								//find best path!!
							}
							//if X2,Y2 != -1,-1, this means that there are already 2 circles highlighted, and you shouldn't do anything
						}
						else{
							//X2,Y2 should never be assigned when X1, Y1 isn't
							highlightedX1 = curNodeX;
							highlightedY1 = curNodeY;
							//clearCircle first if you want it to not just draw over whatever is there
							//Note: we want to embolden the line by making the stroke bigger
								////	This goes outside of the circle radius though
								////	So we have to subtract the difference in stroke (over 2) from the radius
								var strokeDiff = (selectedCircleLineWidth - defaultCircleLineWidth) / 2;
							drawCircle(ctx, circleCenterXLoc, circleCenterYLoc, circleRadius - strokeDiff, selectedCircleLineWidth, "blue");
						}
					}
		        }
			}

		}, false);
	}
	//x and y pairs are the indices for the nodes in the graph
	function getChordPath(x1, y1, x2, y2){
		var url = "";
		url += $("#UTT1_switch").val() + "/";
		url += $("#UTT1_Major").val() + "/";
		url += $("#UTT1_Minor").val() + "/";
		url += $("#UTT2_switch").val() + "/";
		url += $("#UTT2_Major").val() + "/";
		url += $("#UTT2_Minor").val() + "/";
	}
	function buildGraph(){
		var url = "";
		url += $("#UTT1_switch").val() + "/";
		url += $("#UTT1_Major").val() + "/";
		url += $("#UTT1_Minor").val() + "/";
		url += $("#UTT2_switch").val() + "/";
		url += $("#UTT2_Major").val() + "/";
		url += $("#UTT2_Minor").val() + "/";
		clearCanvas();
		highlightedX1 = -1;
		highlightedY1 = -1;
		highlightedX2 = -1;
		highlightedY2 = -1;
		$.get( url, function( data ) {
			if (window.DOMParser){
				parser=new DOMParser();
	  			xmlDoc=parser.parseFromString(data,"text/xml");
	  			curGraph = xmlDoc;
	  			//alert(xmlDoc.getElementsByTagName("chordNode"));//[0].childNodes[0].nodeValue;
	  			chords=xmlDoc.getElementsByTagName("ChordNode");
	  			console.log("chords.length is: " + chords.length);
				for (i = 0; i < chords.length; i++)
				{
					//console.log("current chord name: " + chords[i].getAttribute("chordName"));
					//console.log("current chord xIndex: " + chords[i].getAttribute("xIndex"));
					//console.log("current chord xIndex: " + chords[i].getAttribute("yIndex"));
					var curNodeX = parseInt(chords[i].getAttribute("xIndex"));
					var curNodeY = parseInt(chords[i].getAttribute("yIndex"));
					buildChordNode(curNodeX, curNodeY, chords[i].getAttribute("chordName"));
					chordNodeChildren = chords[i].childNodes;
					console.log("chordNodeChildren.length = " + chordNodeChildren.length);
					for (j = 0; j < chordNodeChildren.length; j++){
						if (chordNodeChildren[j].tagName == "Neighbors"){
							console.log("found the neighbors");
							neighborNodes = chordNodeChildren[j].childNodes;
							console.log("neighborNodes.length = " + neighborNodes.length);
							for (k = 0; k < neighborNodes.length; k++){
								//gotta check for the neighbor tag because there are some blank text tags in between
								if (neighborNodes[k].tagName == "Neighbor"){
									drawArrowBetweenNodes(curNodeX, curNodeY, parseInt(neighborNodes[k].getAttribute("xIndex")), parseInt(neighborNodes[k].getAttribute("yIndex")))
									//console.log("found neighbor at: (" + neighborNodes[k].getAttribute("xIndex") + "," + neighborNodes[k].getAttribute("yIndex") + ")");
								}
							}
						}
						
					}
				}
	  		}
	  		else{//Internet Explorer
	  			alert("Please upgrade to the 21st century and get a different browser");
	  		}
			//buildChordNode({{colNode.xInd}}, {{colNode.yInd}}, "{{colNode.chordName}}");
			//{% for n in colNode.neighbors %}
			//drawArrowBetweenNodes({{colNode.xInd}}, {{colNode.yInd}}, {{n.0.0}}, {{n.0.1}});
			//{% endfor %}
		});
		if (firstTime){
			//instead of using firstTime, we could just do it on document load, as long as the canvas is not visible on docload
			addCanvasListener();
			firstTime = false;
		}
	}

</script>
</html>
